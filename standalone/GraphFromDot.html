<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Network</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" type="text/css">
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style type="text/css">
        #mynetwork {
            width: 600px;
            height: 600px;
            border: 1px solid #357edd;
            border-radius: 0.5rem;
            background-color: rgba(255, 255, 255, 0.8);
        }
        #info {
            position: absolute;
            top: 1vw;
            left: 4vw;
            border: 3px solid #357edd;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            z-index: 1;
            border-radius: 0.5rem;
            font-size: 0.8em;
            font-family: sans-serif;
            max-width: 300px;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }
        p {
            line-height: 12px;
            margin-bottom: -0.5em;
        }
        p:last-of-type {
            margin-bottom: 1px;
        }
        input {
            color: #357edd;
            border: 3px solid #357edd;
            min-width: 6rem;
            border-radius: 0.5rem;
            font-size: 0.8em;
            min-height: 2rem;
        }
        input:hover {
            background-color: #357edd;
            color: white;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            justify-content: center;
            display: flex;
            flex-direction: column;
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 3px solid #357edd;
            border-radius: 0.5rem;
            width: 25%;
            font-family: sans-serif;
            border-radius: 0.5rem;
            align-items: center;
        }

        .modal button {
            color: #357edd;
            border: 3px solid #357edd;
            min-width: 6rem;
            border-radius: 0.5rem;
            font-size: 0.8em;
            min-height: 2rem;
            margin-top: 10px;
        }

        #clusterName{
            color: #357edd;
            min-width: 6rem;
            border: 1px solid black;
            border-radius: 0.5rem;
            font-size: 0.8em;
            min-height: 2rem;
            margin-top: 10px;
            margin-right: 15px;
            margin-left: 10px;
            padding-left: 10px;
        }

        #clusterName:hover {
            background-color: white;
        }
        
        #submitClusterName{
            margin-left: 10px;
            margin-right: 10px;
        }

        #submitClusterName:hover {
            background-color: #357edd;
            color: white;
        }

        #cancelClusterName{
            margin-left: 10px;
            margin-right: 10px;
        }

        #cancelClusterName:hover {
            background-color: #f5532b;
            color: white;
        }
        
    </style>
</head>
<body>
    <div id="page">
        <div id="mynetwork"></div>
        <div id="info">
            <p><b>Controls</b></p>
            <p></p>
            <ul>
                <li><b>left-click</b> to select node/cluster</li>
                <li><b>esc</b> to unselect node(s)/cluster</li>
                <li><b>left-click</b> on empty space to unselect node(s)/cluster(s)</li>
                <li><b>ctrl+left-click</b> to select multiple nodes/clusters</li>
                <li><b>'c'</b> to create cluster from selection (overwrites existing clustering for selected nodes)</li>
                <li><b>double-left-click</b> to open cluster</li>
                <li><b>right-click</b> to save/copy image of current graph</li>
                <li><b>space</b> to toggle node fixed position (<span style="color: rgba(247, 51, 51, 0.918);"><b>experimental!</b></span>)</li>
            </ul>
        </div>
        <div id="buttons">
            <input type="button" id="uploadButton" value="Upload .gv file">
            <input type="button" id="clusterButton" value="Cluster nodes">
        </div>
        <div id="myModal" class="modal">
            <div class="modal-content">
                <label for="clusterName"><b>Please enter a name for the cluster:</b></label>
                <input list="clusterNames" id="clusterName" name="clusterName" />
                <datalist id="clusterNames">
                </datalist>
                <div>
                    <button id="submitClusterName">Submit</button>
                    <button id="cancelClusterName">Cancel</button>
                </div>
            </div>
          </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var network, data;
            var totalSize;
            var selectedNode;
            var options = {
                layout: { 
                    randomSeed: 1
                },
                interaction: {
                    multiselect: true
                },
                physics: {
                    enabled: true
                },
                nodes: {
                    widthConstraint: {
                    maximum: 200,
                },
                }
            };
            var page = document.getElementById("page");
            var container = document.getElementById("mynetwork");
            var info = document.getElementById("info");
            var buttons = document.getElementById("buttons");
            var originalInfoBoxHTML = document.getElementById('info').innerHTML;
            var clusters = new Set();
            var defaultGraph = "digraph source_graph {\n" +
              "\trankdir=LR;\n" +
              "\tnode [shape=circle style=filled fixedsize=true fontsize=20];\n" +
              "\tsize=\"15\";\n" +
              "\n" +
              "\tnode [width=51 fillcolor=white bordercolor=black label=\"WordLog MainDoc\"] 1\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"TASKBAR\" cluster=\"SYSTEM\"] 2\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"Untitled - Google Chrome\" cluster=\"GOOGLE\"] 3\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"Google - Google Chrome\" cluster=\"GOOGLE\"] 4\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"wikipedia - Google Search - Google Chrome\" cluster=\"GOOGLE\"] 5\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"Wikipedia - Google Chrome\" cluster=\"WIKIPEDIA\"] 6\n" +
              "\tnode [width=9 fillcolor=white bordercolor=black label=\"C++ - Wikipedia - Google Chrome\" cluster=\"WIKIPEDIA\"] 7\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"Task Switching\" cluster=\"SYSTEM\"] 8\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"Tab for a Cause - Google Chrome\" cluster=\"GOOGLE\"] 9\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"tab.gladly.io/newtab/ - Google Chrome\" cluster=\"GOOGLE\"] 10\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"java - Google Search - Google Chrome\" cluster=\"GOOGLE\"] 11\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"java.com/en/ - Google Chrome\"] 12\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"Java | Oracle - Google Chrome\"] 13\n" +
              "\tnode [width=11 fillcolor=white bordercolor=black label=\"Save As\" cluster=\"SYSTEM\"] 14\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"New notification\" cluster=\"SYSTEM\"] 15\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"InputLog (Running) - Microsoft Visual Studio\"] 16\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"#welcome | Joshua's Discord Corner - Discord\"] 17\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"Cpp_vs_JavaWordLog_Joshua_20230706145645.docx\"] 18\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"System tray overflow window.\" cluster=\"SYSTEM\"] 19\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"Inputlog 9.5.0.1\"] 20\n" +
              "\n" +
              "\t1 -> 2 [label=\"3\" penwidth=3];\n" +
              "\t1 -> 8 [label=\"4\" penwidth=4];\n" +
              "\t1 -> 14 [label=\"1\" penwidth=1];\n" +
              "\t1 -> 18 [label=\"1\" penwidth=1];\n" +
              "\t2 -> 3 [label=\"1\" penwidth=1];\n" +
              "\t2 -> 15 [label=\"1\" penwidth=1];\n" +
              "\t2 -> 1 [label=\"1\" penwidth=1];\n" +
              "\t2 -> 19 [label=\"1\" penwidth=1];\n" +
              "\t3 -> 4 [label=\"1\" penwidth=1];\n" +
              "\t3 -> 9 [label=\"1\" penwidth=1];\n" +
              "\t4 -> 5 [label=\"1\" penwidth=1];\n" +
              "\t5 -> 6 [label=\"1\" penwidth=1];\n" +
              "\t6 -> 7 [label=\"1\" penwidth=1];\n" +
              "\t7 -> 8 [label=\"2\" penwidth=2];\n" +
              "\t7 -> 3 [label=\"1\" penwidth=1];\n" +
              "\t8 -> 1 [label=\"5\" penwidth=5];\n" +
              "\t8 -> 7 [label=\"2\" penwidth=2];\n" +
              "\t8 -> 16 [label=\"1\" penwidth=1];\n" +
              "\t8 -> 17 [label=\"1\" penwidth=1];\n" +
              "\t9 -> 10 [label=\"1\" penwidth=1];\n" +
              "\t9 -> 11 [label=\"1\" penwidth=1];\n" +
              "\t10 -> 9 [label=\"1\" penwidth=1];\n" +
              "\t11 -> 12 [label=\"1\" penwidth=1];\n" +
              "\t12 -> 13 [label=\"1\" penwidth=1];\n" +
              "\t13 -> 8 [label=\"1\" penwidth=1];\n" +
              "\t14 -> 1 [label=\"1\" penwidth=1];\n" +
              "\t15 -> 8 [label=\"1\" penwidth=1];\n" +
              "\t16 -> 2 [label=\"1\" penwidth=1];\n" +
              "\t17 -> 8 [label=\"1\" penwidth=1];\n" +
              "\t18 -> 1 [label=\"1\" penwidth=1];\n" +
              "\t19 -> 20 [label=\"1\" penwidth=1];\n" +
              "}\n";

            function initializeNetwork() {
                // Set up initial network settings
                page.style.marginLeft = window.innerWidth * 0.03 + "px";
                container.style.width = window.innerWidth * 0.94 + "px";
                container.style.height = window.innerHeight * 0.9 + "px";
                buttons.style.marginTop = window.innerHeight * 0.01 + "px";

                [network, data] = dotToNetwork(defaultGraph, options);
            }

            function loadDotFile() {
                updateInfoBox([]) // clear info box
                // Create an input file
                var input = document.createElement("input");
                input.type = "file";

                // Add an event listener to the input file
                input.addEventListener("change", function() {
                    var reader = new FileReader();
                    reader.addEventListener("load", function() {
                        dotString = reader.result;
                        try {
                            network, data = dotToNetwork(dotString);
                            // TODO remove temporary fix below
                            defaultGraph = dotString;
                            initializeNetwork();
                            initializeNetwork();
                        } catch (err) {
                            alert("Error loading network: " + err.message);
                        }
                    });
                    reader.readAsText(input.files[0]);
                });

                input.click();
            }

            function createNetwork() {
                var network = new vis.Network(container, data, options);
                network.on("selectNode", function (params) {
                    updateInfoBox(params.nodes);
                });

                network.on("doubleClick", function (params) {
                    openClusters(params.nodes);
                });

                network.on("deselectNode", function (params) {
                    updateInfoBox(params.nodes);
                });

                network.on("dragStart", function (params) {
                    updateInfoBox(params.nodes);
                });

                // Ensure nodes are fixed after dragging
                network.on("dragEnd", function (params) {
                    for (nodeId of network.getSelection().nodes) {
                        //TODO fix the code below; not sure what it's meant to do
                        var node = network.body.nodes[nodeId];
                        network.body.data.nodes[nodeId] = node;
                    }
                })

                return network;
            }

            function updateInfoBox(nodes) {
                var html = "<p><b>Selected Source Category:</b><p>";
                html += "<div id=\"selected_nodes\">";
                if (nodes.length > 0) {
                    var selectedSize = 0;
                    for (nodeId of nodes) {
                        console.log(nodeId, network.isCluster(nodeId));
                        if (network.isCluster(nodeId) === false) {
                            var node = network.body.nodes[nodeId];
                            selectedSize += node.shape.radius;
                            html += `<p>🌿${node.options.title}</p>`;
                        } else {
                            var cluster = network.body.nodes[nodeId];
                            html += `<p>🌳${cluster.options.title}</p>`;
                            html += `<p style="margin-left: 15px;"><b>Category contains links:</b></p>`;
                            for(let node in cluster.containedNodes){  // loop over contained nodes
                                selectedSize += cluster.containedNodes[node].shape.radius;
                                html += `<p style="margin-left: 30px;">🌿${cluster.containedNodes[node].options.title}</p>`; // add label to info box (TODO maybe fix style setting?)
                            }
                        }
                    }
                    html += "</div>";
                    info.innerHTML = html;
                    var selectedPercentage = Math.round(selectedSize / totalSize * 100);
                    // add horizontal line
                    info.innerHTML += `<hr style="margin-top: 1em; margin-bottom: 0.5em;">`;
                    info.innerHTML += `<p><b>Relative Time Spent:</b> ${selectedPercentage}%</p>`;
                } else {
                    info.innerHTML = originalInfoBoxHTML;
                }
            }

            function openClusters(nodes) {
                updateInfoBox([]) // clear info box
                for (node of nodes) {
                    if (network.isCluster(node) === true) {
                        network.openCluster(node); // TODO think we lose information on edge labels here, should be fixed
                        // reproduce behaviour by clustering the example network, then clicking on a cluster; all outgoing
                        // edges' labels are lost. Also, the to-cluster edge label is not correct (values don't seem to be added)
                        // we should have at least a value of 7 from MainDoc to SYSTEM but it says 3 (the number of nodes within the cluster our MainDoc node has an edge to)
                    }
                }
            }

            function createClusters() {
                updateInfoBox([]) // clear info box
                // Cluster nodes based on DOT-defined clusters
                const new_clusters = data.nodes.reduce((acc, node) => { // create local variable new_clusters
                    if (node.cluster) {
                        if (!acc[node.cluster]) {
                            acc[node.cluster] = [];
                        }
                        acc[node.cluster].push(node.id);
                    }
                    return acc;
                }, {});

                // Return if no clusters are defined (so graph doesn't move around)
                var clusterCount = Object.entries(new_clusters).length
                if (clusterCount === 0) return;
                network = createNetwork();

                // Generate colors for each label
                var colors = generateColors(clusterCount) // TODO these could be pre-defined as well; currently they are deterministically 'random'
                for (const [label, nodes] of Object.entries(new_clusters)) {
                    var relativeClusterSize = nodes.reduce((acc, node) => {
                        return acc + data.nodes[node - 1].size;
                    }, 0)/totalSize;
                    relativeClusterSize = Math.round(relativeClusterSize * 100);

                    var truncatedLabel = label;
                    var clusterTruncateSize = 10;
                    if (label.length > clusterTruncateSize) {
                        truncatedLabel = label.substring(0, clusterTruncateSize) + "...";
                    }

                    var clusterOptionsByData = {
                        joinCondition: function (childOptions) {
                            return childOptions.cluster === label;
                        },
                        clusterNodeProperties: {
                            id: "cluster:" + label,
                            borderWidth: 3,
                            shape: "box",
                            color: colors.pop(),
                            label: `${truncatedLabel} (${relativeClusterSize}%)`,
                            title: `${label} (${relativeClusterSize}%)`,
                        },
                    };
                    network.cluster(clusterOptionsByData);
                }

                clusters.clear();  // clear existing clusters set
                for(cluster of Object.keys(new_clusters)){
                    clusters.add(cluster);  // add new clusters to set
                }
            }
            

            function dotToNetwork(dotString, options) {
                // Convert DOT string to network
                var data = vis.parseDOTNetwork(dotString);
                modifyEdges(data.edges);
                modifyNodes(data.nodes);
                var network = createNetwork();

                return [network, data];
            }

            function modifyEdges(edges) {
                // Modify edges based on DOT-defined edge attributes
                for (var i = 0; i < edges.length; i++) {
                    // Rename penwidth to width
                    edges[i].width = edges[i].penwidth;
                    delete edges[i].penwidth;
                }
            }

            function modifyNodes(nodes) {
                totalSize = 0;
                // Modify nodes based on DOT-defined node attributes
                for (var i = 0; i < nodes.length; i++) {
                    // Rename width to size (use 5 if no width is defined)
                    nodes[i].size = nodes[i].width || 5;
                    totalSize += nodes[i].size;
                    delete nodes[i].width;

                    nodes[i].shape = "dot";
                    nodes[i].fixed = {x: false, y: false};

                    nodes[i].color = nodes[i].color || {};
                    nodes[i].color.border = nodes[i].bordercolor || "black";

                    if(nodes[i].cluster){
                        clusters.add(nodes[i].cluster);
                    }

                    // check if label is too long (over labelTruncateSize characters); if this is the case, truncate it & store full label in title (for use in info box)
                    nodes[i].title = nodes[i].label;
                    var labelTruncateSize = 20;
                    if (nodes[i].label.length > labelTruncateSize) {
                        nodes[i].label = nodes[i].label.substring(0, labelTruncateSize) + "...";
                    }

                    nodes[i].chosen = {
                        node: function(values, id, selected, hovering) {
                            selectedNode = nodes[id - 1]
                        }
                    }
                }
                console.log(totalSize)
            }

            function generateColors(numColors) {
                // Generate colors for clusters
                var colors = [];
                var hueIncrement = 360 / numColors;

                for (var i = 0; i < numColors; i++) {
                    var hue = i * hueIncrement;
                    var color = 'hsl(' + hue + ', 85%, 65%)';
                    colors.push(color);
                }

                return colors;
            }

            // Initial setup
            // TODO: Currently doesn't work if I don't call initializeNetwork() twice, not sure why
            initializeNetwork();
            initializeNetwork();

            // Event listeners
            document.getElementById("clusterButton").addEventListener("click", createClusters);
            document.getElementById("uploadButton").addEventListener("click", loadDotFile);
            document.addEventListener("keydown", function(event) {
                if (event.code === "Space") { // TODO figure out why this only updates after another interaction on-screen
                    for (nodeId of network.getSelection().nodes) {
                        var node = network.body.nodes[nodeId];
                        // TODO figure out why, when dragging a node and then pressing space, the node's 'fixed.x/y' attribute is already set to true?
                        node.options.fixed.x = !node.options.fixed.x;
                        node.options.fixed.y = !node.options.fixed.y;
                        node.options.color = {background: (node.options.fixed.x ? "red" : "white"), border: "black" };
                        // network.body.nodes.update({id: node.id, fixed: node.fixed, color: node.color}); // TODO nodes is structured differently here
                        network.body.nodes[nodeId] = node; // TODO this is a hacky way to update the node, but it works
                        console.log(node);
                    }
                }
                if(event.code === "KeyC") {
                    // don't create cluster if modal is open
                    var modal = document.getElementById('myModal');
                    if (modal.style.display === "block") {
                        return;
                    }
                    createNewCluster(network.getSelection().nodes);
                }

                if (event.code === "Escape") {
                    var modal = document.getElementById('myModal');
                    if (modal.style.display === "block") {
                        modal.style.display = "none";
                    }else{ // only unselect nodes if modal is not open
                        network.unselectAll();
                        updateInfoBox([]);
                    }
                }
            });
            function createNewCluster(nodes) {
                // check if at least 2 nodes are selected, OR if a cluster is selected
                if (nodes.length <= 1 && network.isCluster(nodes[0]) === false){
                    alert("Please select at least 2 nodes to create a cluster.");
                    return;
                };
                // show prompt to get cluster name
                document.getElementById('myModal').style.display = "block";
                setTimeout(function() { // prevent C from being typed in cluster name input field
                    var inputField = document.getElementById('clusterName');
                    inputField.value = ""; // clear input field
                    inputField.focus(); // focus on input field
                    inputField.addEventListener('keydown', function(event) {
                        if (event.code === "Enter") {
                                document.getElementById('submitClusterName').click();
                            }
                    });
                }, 0);

                // populate datalist with existing cluster names
                var clusterNames = document.getElementById('clusterNames');
                clusterNames.innerHTML = "";
                for(cluster of clusters){
                    var option = document.createElement('option');
                    option.value = cluster;
                    clusterNames.appendChild(option);
                }
                document.getElementById('cancelClusterName').onclick = function() {
                    document.getElementById('myModal').style.display = "none";
                }
                document.getElementById('submitClusterName').onclick = function() {
                    var clusterName = document.getElementById('clusterName').value;
                    document.getElementById('myModal').style.display = "none";
                    if (clusterName == null || clusterName == "") {
                    return;
                    }
                    clusters.add(clusterName);
                    for (node of nodes) {
                        // check if cluster
                        if(network.isCluster(node) === true){
                            // get all nodes in cluster
                            var cluster = network.body.nodes[node];
                            for(let node in cluster.containedNodes){  // loop over contained nodes
                                // add cluster name to node
                                data.nodes[cluster.containedNodes[node].id - 1].cluster = clusterName;
                            }
                        }else{
                            data.nodes[node - 1].cluster = clusterName;
                        }
                    }
                    // press cluster button
                    document.getElementById("clusterButton").click();
                }
        }
        });
    </script>
</body>
</html>