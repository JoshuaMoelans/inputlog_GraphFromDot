<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Network</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" type="text/css">
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style type="text/css">
        #mynetwork {
            border: 1px solid #357edd;
            border-radius: 0.5rem;
            background-color: rgba(255, 255, 255, 0.8);
        }

        .infobox {
            top: 3vw;
            border: 3px solid #357edd;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            z-index: 1;
            border-radius: 0.5rem;
            font-size: 0.7em;
            font-family: sans-serif;
        }

        #tasks {
            right: 3vw;
            position: absolute;
            min-height: 10px;
            max-height: 200px;
            min-width: 20px;
            max-width: 200px;
            overflow-y: auto;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        #info {
            left: 4vw;
            position: absolute;
            max-height: 300px;
            min-height: 10px;
            max-width: 300px;
            min-width: 20px;
            overflow-y: auto;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .close-button {
            position: absolute;
            right: 10px;
            top: 3px;
            background: none;
            border: none;
            font-size: 15px;
            color: #357edd;
            cursor: pointer;
        }

        #info-close-button {
            left: 10px;
            right: auto;
            cursor: pointer;
        }

        /* For Chrome, Safari, and Opera */
        .infobox::-webkit-scrollbar {
            width: 10px;
        }

        .infobox::-webkit-scrollbar-track {
            background: #69a7f7d3;

        }

        .infobox::-webkit-scrollbar-thumb {
            background: #357edd;

        }

        .infobox::-webkit-scrollbar-thumb:hover {
            background: #357edd;
        }

        p {
            line-height: 12px;
            margin-bottom: -0.5em;
        }
        p:last-of-type {
            margin-bottom: 1px;
        }
        input {
            color: #357edd;
            border: 3px solid #357edd;
            border-radius: 0.5rem;
            font-size: 0.8em;
            min-height: 2rem;
        }
        input:hover {
            background-color: #357edd;
            color: white;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            justify-content: center;
            display: flex;
            flex-direction: column;
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 3px solid #357edd;
            border-radius: 0.5rem;
            width: 25%;
            font-family: sans-serif;
            border-radius: 0.5rem;
            align-items: center;
        }

        .modal button {
            color: #357edd;
            border: 3px solid #357edd;
            min-width: 6rem;
            border-radius: 0.5rem;
            font-size: 0.8em;
            min-height: 2rem;
            margin-top: 10px;
        }

        #clusterName{
            color: #357edd;
            min-width: 6rem;
            border: 1px solid black;
            border-radius: 0.5rem;
            font-size: 0.8em;
            min-height: 2rem;
            margin-top: 10px;
            margin-right: 15px;
            margin-left: 10px;
            padding-left: 10px;
        }

        #clusterName:hover {
            background-color: white;
        }
        
        #submitClusterName{
            margin-left: 10px;
            margin-right: 10px;
        }

        #submitClusterName:hover {
            background-color: #357edd;
            color: white;
        }

        #cancelClusterName{
            margin-left: 10px;
            margin-right: 10px;
        }

        #cancelClusterName:hover {
            background-color: #f5532b;
            color: white;
        }
        #colorPickerContainer {
            position: fixed;
            z-index: 1;
            display: flex;
            align-items: center;
        }

        #nodeColor {
            position: relative;
            z-index: 1;
            width: 25px;
            border: 0;
        }

        .title {
            width: 100%;
            text-align: center;
            padding: 5px 0;
        }

        .title h1 {
            margin: 0;
            font-size: 24px;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div class="title">
        <h1>Source network graph (dynamic)</h1>
    </div>
    <div id="page">
        <div id="colorPickerContainer" style="display: none;">
            <input type="color" id="nodeColor" name="nodeColor" value="#ff0000" style="display: none;">
        </div>
        <div id="mynetwork"></div>
        <div id="info" class="infobox">
            <button class="close-button" id="info-close-button">x</button>
            <div id="infocontent">
                <p><b>Legend:</b></p>
                <p> Each circle is a node; <br> a group of circles is a cluster</p>
                <p><b>Activities:</b></p>
                <p>Select node: <b>left-click node</b></p>
                <p>Select multiple nodes: <b>ctrl+left-click nodes</b></p>
                <p>Group selection of nodes: press <b>'c'</b> + name the cluster</p>
                <P>Open cluster: <b>double click</b> cluster</P>
                <p>Unselect node/cluster(s): <b>left click</b> on empty page</p>
                <p>Untie the cluster: <b>double left-click</b> cluster (regroup them via the cluster nodes button)</p>
                <br>
                <p>Change colour of node: <b>double left-click</b> on node</p>
                <p>Fixate position of node: press <b>space bar</b> when dragging to fixate in-place</p>
                <p>Save image: <b>right-click</b> current network graph</p>
            </div>
        </div>
        <div id="tasks" class="infobox">
            <button class="close-button" id="tasks-close-button">x</button>
            <div id="taskscontent">
                <p><b>Cluster additional source types:</b></p>
                <ul style="margin-left: -25px; margin-top: 0px;">
                    <li>Content</li>
                    <li>Spelling</li>
                    <li>Formulation</li>
                    <li>Task</li>
                    <li>Unrelated</li>
                    <li>Other, provide your own typology</li>
                </ul>
            </div> 
        </div>
        <div id="buttons">
            <input type="button" id="uploadButton" value="Upload .gv file">
            <input type="button" id="saveButton" value="Save as .gv file">
            <input type="button" id="clusterButton" value="Cluster nodes">
        </div>
        <div id="myModal" class="modal">
            <div class="modal-content">
                <label for="clusterName"><b>Please enter a name for the cluster:</b></label>
                <input list="clusterNames" id="clusterName" name="clusterName" />
                <datalist id="clusterNames">
                </datalist>
                <div>
                    <button id="submitClusterName">Submit</button>
                    <button id="cancelClusterName">Cancel</button>
                </div>
            </div>
          </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var network, data;
            var nodeDict;
            var totalSize;
            var selectedNode;
            var options = {
                layout: { 
                    randomSeed: 1
                },
                interaction: {
                    multiselect: true
                },
                physics: {
                    enabled: true
                },
                nodes: {
                    widthConstraint: {
                        maximum: 200
                    },
                },
                edges: {
                    color: {
                        inherit: false
                    }
                }
            };
            var page = document.getElementById("page");
            var container = document.getElementById("mynetwork");
            var info = document.getElementById("infocontent");
            var buttons = document.getElementById("buttons");
            var originalInfoBoxHTML = document.getElementById('infocontent').innerHTML;
            var clusters = new Set();
            var dragging = false;
            var changedNodes = new Map();
            var defaultGraph = "digraph source_graph {\n" +
              "\trankdir=LR;\n" +
              "\tnode [shape=circle style=filled fixedsize=true fontsize=20];\n" +
              "\tsize=\"15\";\n" +
              "\n" +
              "\tnode [width=35 fillcolor=#1856b9 bordercolor=black label=\"Your Document\"] 1\n" +
              "\tnode [width=3 fillcolor=white bordercolor=black label=\"TASKBAR\" cluster=\"SYSTEM\"] 2\n" +
              "\tnode [width=1 fillcolor=white bordercolor=black label=\"Untitled - Google Chrome\" cluster=\"GOOGLE\"] 3\n" +
              "\tnode [width=0 fillcolor=white bordercolor=black label=\"Google - Google Chrome\" cluster=\"GOOGLE\"] 4\n" +
              "\tnode [width=2 fillcolor=white bordercolor=black label=\"wikipedia - Google Search - Google Chrome\" cluster=\"GOOGLE\"] 5\n" +
              "\tnode [width=2 fillcolor=white bordercolor=black label=\"Wikipedia - Google Chrome\" cluster=\"WIKIPEDIA\"] 6\n" +
              "\tnode [width=7 fillcolor=white bordercolor=black label=\"C++ - Wikipedia - Google Chrome\" cluster=\"WIKIPEDIA\"] 7\n" +
              "\tnode [width=2 fillcolor=white bordercolor=black label=\"Task Switching\" cluster=\"SYSTEM\"] 8\n" +
              "\tnode [width=1 fillcolor=white bordercolor=black label=\"Tab for a Cause - Google Chrome\" cluster=\"GOOGLE\"] 9\n" +
              "\tnode [width=0 fillcolor=white bordercolor=black label=\"tab.gladly.io/newtab/ - Google Chrome\" cluster=\"GOOGLE\"] 10\n" +
              "\tnode [width=0 fillcolor=white bordercolor=black label=\"java - Google Search - Google Chrome\" cluster=\"GOOGLE\"] 11\n" +
              "\tnode [width=2 fillcolor=white bordercolor=black label=\"java.com/en/ - Google Chrome\"] 12\n" +
              "\tnode [width=3 fillcolor=white bordercolor=black label=\"Java | Oracle - Google Chrome\"] 13\n" +
              "\tnode [width=14  fillcolor=white bordercolor=black label=\"Save As\" cluster=\"SYSTEM\"] 14\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"New notification\" cluster=\"SYSTEM\"] 15\n" +
              "\tnode [width=4 fillcolor=white bordercolor=black label=\"InputLog (Running) - Microsoft Visual Studio\"] 16\n" +
              "\tnode [width=3 fillcolor=white bordercolor=black label=\"#welcome | Joshua's Discord Corner - Discord\"] 17\n" +
              "\tnode [width=4 fillcolor=white bordercolor=black label=\"Cpp_vs_JavaWordLog_Joshua_20230706145645.docx\"] 18\n" +
              "\tnode [width=5 fillcolor=white bordercolor=black label=\"System tray overflow window.\" cluster=\"SYSTEM\"] 19\n" +
              "\tnode [width=7 fillcolor=white bordercolor=black label=\"Inputlog 9.5.0.1\"] 20\n" +
              "\n" +
              "\t1 -> 2 [label=\"3\" penwidth=3];\n" +
              "\t1 -> 8 [label=\"4\" penwidth=4];\n" +
              "\t1 -> 14 [label=\"1\" penwidth=1];\n" +
              "\t1 -> 18 [label=\"1\" penwidth=1];\n" +
              "\t2 -> 3 [label=\"1\" penwidth=1];\n" +
              "\t2 -> 15 [label=\"1\" penwidth=1];\n" +
              "\t2 -> 1 [label=\"1\" penwidth=1];\n" +
              "\t2 -> 19 [label=\"1\" penwidth=1];\n" +
              "\t3 -> 4 [label=\"1\" penwidth=1];\n" +
              "\t3 -> 9 [label=\"1\" penwidth=1];\n" +
              "\t4 -> 5 [label=\"1\" penwidth=1];\n" +
              "\t5 -> 6 [label=\"1\" penwidth=1];\n" +
              "\t6 -> 7 [label=\"1\" penwidth=1];\n" +
              "\t7 -> 8 [label=\"2\" penwidth=2];\n" +
              "\t7 -> 3 [label=\"1\" penwidth=1];\n" +
              "\t8 -> 1 [label=\"5\" penwidth=5];\n" +
              "\t8 -> 7 [label=\"2\" penwidth=2];\n" +
              "\t8 -> 16 [label=\"1\" penwidth=1];\n" +
              "\t8 -> 17 [label=\"1\" penwidth=1];\n" +
              "\t9 -> 10 [label=\"1\" penwidth=1];\n" +
              "\t9 -> 11 [label=\"1\" penwidth=1];\n" +
              "\t10 -> 9 [label=\"1\" penwidth=1];\n" +
              "\t11 -> 12 [label=\"1\" penwidth=1];\n" +
              "\t12 -> 13 [label=\"1\" penwidth=1];\n" +
              "\t13 -> 8 [label=\"1\" penwidth=1];\n" +
              "\t14 -> 1 [label=\"1\" penwidth=1];\n" +
              "\t15 -> 8 [label=\"1\" penwidth=1];\n" +
              "\t16 -> 2 [label=\"1\" penwidth=1];\n" +
              "\t17 -> 8 [label=\"1\" penwidth=1];\n" +
              "\t18 -> 1 [label=\"1\" penwidth=1];\n" +
              "\t19 -> 20 [label=\"1\" penwidth=1];\n" +
              "}\n";

            function initializeNetwork() {
                // Set up initial network settings
                page.style.marginLeft = window.innerWidth * 0.03 + "px";
                container.style.width = window.innerWidth * 0.94 + "px";
                container.style.height = window.innerHeight * 0.85 + "px";
                buttons.style.marginTop = window.innerHeight * 0.01 + "px";

                [network, data] = dotToNetwork(defaultGraph, options);
            }

            function loadDotFile() {
                updateInfoBox([]) // clear info box
                // Create an input file
                var input = document.createElement("input");
                input.type = "file";

                // Add an event listener to the input file
                input.addEventListener("change", function() {
                    var reader = new FileReader();
                    reader.addEventListener("load", function() {
                        dotString = reader.result;
                        try {
                            network, data = dotToNetwork(dotString);
                            // TODO remove temporary fix below
                            defaultGraph = dotString;
                            initializeNetwork();
                            initializeNetwork();
                        } catch (err) {
                            alert("Error loading network: " + err.message);
                        }
                    });
                    reader.readAsText(input.files[0]);
                });

                input.click();
            }

            function saveDotFile() {
                // Get graph data from vis.js
                const nodes = network.body.data.nodes._data;
                const edges = network.body.data.edges._data;
                
                // Build DOT string
                let dotString = 'digraph myGraph {\n';
                dotString += "\trankdir=LR;\n";
                dotString += "\tnode [shape=circle style=filled fixedsize=true fontsize=20];\n";
                dotString += "\tsize=\"15\";\n\n";

                nodes.forEach(node => {
                    console.log(node);
                    var [label, weight] = [node.title, node.width]; // use title as stored label (actual label has been truncated) and width as weight
                    clusterInfo = nodeDict[node.id].cluster ? ` cluster="${nodeDict[node.id].cluster}"` : "";
                    dotString += `\tnode [width=${weight} fillcolor=\"${node.color.background}\" bordercolor=${node.color.border} label="${label}"${clusterInfo}] ${node.id};\n`;
                });
                dotString += '\n';

                edges.forEach(edge => {
                    dotString += `\t${edge.from} -> ${edge.to} [label="${edge.label}" penwidth=${edge.label}];\n`;
                });
                dotString += '}';

                var blob = new Blob([dotString], {type: "text/plain;charset=utf-8"});
                saveAs(blob, "network.gv");
            }

            function createNetwork() {
                var network = new vis.Network(container, data, options);
                network.on("selectNode", function (params) {
                    updateInfoBox(params.nodes);
                    console.log(network.body.nodes)
                    console.log(network.getSelection().nodes)
                });

                network.on("doubleClick", function (params) {
                    openClusters(params.nodes);
                });

                network.on("deselectNode", function (params) {
                    updateInfoBox(params.nodes);
                    var colorPickerContainer = document.getElementById('colorPickerContainer');
                    colorPickerContainer.style.display = 'none';
                });

                network.on("dragStart", function (params) {
                    dragging = true;
                    var colorPickerContainer = document.getElementById('colorPickerContainer');
                    colorPickerContainer.style.display = 'none';
                });

                // Ensure nodes are fixed after dragging
                network.on("dragEnd", function (params) {
                    dragging = false;
                    for (const [nodeId, changes] of changedNodes) {
                        network.body.data.nodes.update({id: nodeId, fixed: changes.fixed, color: changes.color});
                    }
                    changedNodes.clear();
                })
                return network;
            }

            function updateInfoBox(nodes) {
                var html = "<p><b>Selected Source Categories:</b><p>";
                html += "<div id=\"selected_nodes\">";
                if (nodes.length > 0) {
                    var selectedSize = 0;
                    for (nodeId of nodes) {
                        console.log(nodeId, network.isCluster(nodeId));
                        if (network.isCluster(nodeId) === false) {
                            var node = network.body.nodes[nodeId];
                            selectedSize += node.options.width;
                            html += `<p>ðŸŒ¿${node.options.title}</p>`;
                        } else {
                            var cluster = network.body.nodes[nodeId];
                            html += `<p>ðŸŒ³${cluster.options.title}</p>`;
                            html += `<p style="margin-left: 15px;"><b>Category contains links:</b></p>`;
                            for(let node in cluster.containedNodes){  // loop over contained nodes
                                selectedSize += cluster.containedNodes[node].options.width;
                                html += `<p style="margin-left: 30px;">ðŸŒ¿${cluster.containedNodes[node].options.title}</p>`; // add label to info box (TODO maybe fix style setting?)
                            }
                        }
                    }
                    html += "</div>";
                    // build actual info box innerHTML
                    var selectedPercentage = Math.round(selectedSize);
                    info.innerHTML = `<p><b>Total Relative Time Spent:</b> ${selectedPercentage}%</p>`; // start with total relative time spent
                    info.innerHTML += `<hr style="margin-top: 1em; margin-bottom: 0.5em;">`;
                    info.innerHTML += html;
                    // add horizontal line
                } else {
                    info.innerHTML = originalInfoBoxHTML;
                }
            }

            function openClusters(nodes) {
                updateInfoBox([]) // clear info box
                for (node of nodes) {
                    if (network.isCluster(node) === true) {
                        // loop over all nodes in cluster and colour them the same as the cluster node
                        var cluster = network.body.nodes[node];
                        for(let child_node in cluster.containedNodes){  // loop over contained nodes
                            // set color of node to color of cluster
                            // TODO figure out why this only works after clustering at least twice (sometimes even more needed?) feels funky A.F.
                            network.body.data.nodes.update({id: cluster.containedNodes[child_node].id, color: {background: cluster.options.color.background}});
                        }
                        network.openCluster(node); // TODO think we lose information on edge labels here, should be fixed
                        // reproduce behaviour by clustering the example network, then clicking on a cluster; all outgoing
                        // edges' labels are lost. Also, the to-cluster edge label is not correct (values don't seem to be added)
                        // we should have at least a value of 7 from MainDoc to SYSTEM but it says 3 (the number of nodes within the cluster our MainDoc node has an edge to)
                    } else {
                        // allow user to select node color TODO transfer over to nodes when clustering
                        var node = network.body.nodes[node];
                        document.getElementById('nodeColor').value = node.options.color.background;
                        var colorPickerContainer = document.getElementById('colorPickerContainer');
                        colorPickerContainer.style.left = event.clientX + 10 + 'px';
                        colorPickerContainer.style.top = event.clientY + 5 +'px';
                        colorPickerContainer.style.display = 'flex';

                        var colorInput = document.getElementById('nodeColor');
                        colorInput.style.display = 'block';
                        colorInput.focus();
                        colorInput.click();

                        colorInput.onchange = function() {
                            node.options.color.background = colorInput.value;
                            data.nodes[node.id - 1].color.background = colorInput.value;
                            colorInput.style.display = 'none';
                        }
                    }
                }
            }

            function createClusters() {
                updateInfoBox([]) // clear info box
                // Cluster nodes based on DOT-defined clusters
                const new_clusters = data.nodes.reduce((acc, node) => { // create local variable new_clusters
                    if (node.cluster) {
                        if (!acc[node.cluster]) {
                            acc[node.cluster] = [];
                        }
                        acc[node.cluster].push(node.id);
                    }
                    return acc;
                }, {});

                // Return if no clusters are defined (so graph doesn't move around)
                var clusterCount = Object.entries(new_clusters).length
                if (clusterCount === 0) return;
                network = createNetwork();

                // Generate colors for each label
                var colors = generateColors(clusterCount) // TODO these could be pre-defined as well; currently they are deterministically 'random'
                for (const [label, nodes] of Object.entries(new_clusters)) {
                    var relativeClusterSize = nodes.reduce((acc, node) => {
                        return acc + nodeDict[node].width;
                    }, 0);
                    relativeClusterSize = Math.round(relativeClusterSize);

                    var truncatedLabel = label;
                    var clusterTruncateSize = 10;
                    if (label.length > clusterTruncateSize) {
                        truncatedLabel = label.substring(0, clusterTruncateSize) + "...";
                    }

                    var clusterOptionsByData = {
                        joinCondition: function (childOptions) {
                            return childOptions.cluster === label;
                        },
                        clusterNodeProperties: {
                            id: "cluster:" + label,
                            borderWidth: 3,
                            shape: "dot",
                            color: colors.pop(),
                            label: `ðŸŒ³${truncatedLabel}\n(${relativeClusterSize}%)`,
                            title: `${label} (${relativeClusterSize}%)`,
                            size: Math.max(relativeClusterSize, 3), // minimum size for nodes
                            width: relativeClusterSize
                        },
                    };
                    network.cluster(clusterOptionsByData);
                }

                clusters.clear();  // clear existing clusters set
                for(cluster of Object.keys(new_clusters)){
                    clusters.add(cluster);  // add new clusters to set
                }
            }
            

            function dotToNetwork(dotString, options) {
                // Convert DOT string to network
                var data = vis.parseDOTNetwork(dotString);
                modifyEdges(data.edges);
                modifyNodes(data.nodes);
                var network = createNetwork();
                return [network, data];
            }

            function modifyEdges(edges) {
                // Modify edges based on DOT-defined edge attributes
                for (var i = 0; i < edges.length; i++) {
                    // Rename penwidth to width
                    edges[i].width = edges[i].penwidth;
                    delete edges[i].penwidth;
                }
            }

            function modifyNodes(nodes) {
                nodeDict = {};
                // Modify nodes based on DOT-defined node attributes
                for (var i = 0; i < nodes.length; i++) {
                    // Rename width to size
                    nodes[i].size = nodes[i].width;

                    nodes[i].shape = "dot";
                    nodes[i].fixed = {x: false, y: false};

                    nodes[i].color = nodes[i].color || {};
                    nodes[i].color.border = nodes[i].bordercolor || "black";

                    if(nodes[i].cluster){
                        clusters.add(nodes[i].cluster);
                    }

                    // check if label is too long (over labelTruncateSize characters); if this is the case, truncate it & store full label in title (for use in info box)
                    nodes[i].title = nodes[i].label;
                    var labelTruncateSize = 20;
                    if (nodes[i].label.length > labelTruncateSize) {
                        nodes[i].label = nodes[i].label.substring(0, labelTruncateSize) + "...";
                    }

                    nodes[i].chosen = {
                        node: function(values, id, selected, hovering) {
                            selectedNode = nodes[id - 1]
                        }
                    }
                }
                nodes.forEach(element => {
                    element.label = element.label + "\n(" + Math.round(element.size) + "%)";
                    element.width = element.size;
                    element.size = Math.max(3, element.size); // minimum size for nodes
                });
                // loop over nodes and add to newnodedict based on id
                for (var i = 0; i < nodes.length; i++) {
                    nodeDict[nodes[i].id] = nodes[i];
                }
            }

            function generateColors(numColors) {
                // Generate colors for clusters
                var colors = [];
                var hueIncrement = 360 / numColors;

                for (var i = 0; i < numColors; i++) {
                    var hue = i * hueIncrement;
                    var color = 'hsl(' + hue + ', 85%, 65%)';
                    colors.push(color);
                }

                return colors;
            }

            // Initial setup
            // TODO: Currently doesn't work if I don't call initializeNetwork() twice, not sure why
            initializeNetwork();
            initializeNetwork();

            // Event listeners
            document.getElementById("clusterButton").addEventListener("click", createClusters);
            document.getElementById("uploadButton").addEventListener("click", loadDotFile);
            document.getElementById("saveButton").addEventListener("click", saveDotFile);
            document.addEventListener("keydown", function(event) {
                if (event.code === "Space") { 
                    //TODO: weird behavior with clusters
                    for (nodeId of network.getSelection().nodes) {
                        var node = network.body.nodes[nodeId];
                        console.log(node)
                        var fixed = {x: !node.options.fixed.x || dragging, y: !node.options.fixed.y || dragging};
                        var color = {background: node.options.color.background, border: (fixed.x ? "red" : "black")};

                        if (dragging === true) {
                            changedNodes.set(nodeId, {fixed: fixed, color: color});
                            console.log(changedNodes)
                        } else {
                            network.body.data.nodes.update({id: node.id, fixed: fixed, color: color}); // TODO nodes is structured differently here
                        }
                    }
                    // Prevents space from clicking buttons when tabbing accidentally
                    event.preventDefault();
                }
                if(event.code === "KeyC" && !event.ctrlKey) {
                    // don't create cluster if modal is open
                    var modal = document.getElementById('myModal');
                    if (modal.style.display === "block") {
                        return;
                    }
                    createNewCluster(network.getSelection().nodes);
                }

                if (event.code === "Escape") {
                    var modal = document.getElementById('myModal');
                    if (modal.style.display === "block") {
                        modal.style.display = "none";
                    }else{ // only unselect nodes if modal is not open
                        network.unselectAll();
                        updateInfoBox([]);
                    }
                    // hide color picker
                    var colorPickerContainer = document.getElementById('colorPickerContainer');
                    colorPickerContainer.style.display = 'none';
                }
            });
            function createNewCluster(nodes) {
                // check if at least 2 nodes are selected, OR if a cluster is selected
                if (nodes.length <= 1 && network.isCluster(nodes[0]) === false){
                    alert("Please select at least 2 nodes to create a cluster.");
                    return;
                };
                // show prompt to get cluster name
                document.getElementById('myModal').style.display = "block";
                setTimeout(function() { // prevent C from being typed in cluster name input field
                    var inputField = document.getElementById('clusterName');
                    inputField.value = ""; // clear input field
                    inputField.focus(); // focus on input field
                    inputField.addEventListener('keydown', function(event) {
                        if (event.code === "Enter") {
                                document.getElementById('submitClusterName').click();
                            }
                    });
                }, 0);

                // populate datalist with existing cluster names
                var clusterNames = document.getElementById('clusterNames');
                clusterNames.innerHTML = "";
                for(cluster of clusters){
                    var option = document.createElement('option');
                    option.value = cluster;
                    clusterNames.appendChild(option);
                }
                document.getElementById('cancelClusterName').onclick = function() {
                    document.getElementById('myModal').style.display = "none";
                }
                document.getElementById('submitClusterName').onclick = function() {
                    var clusterName = document.getElementById('clusterName').value;
                    document.getElementById('myModal').style.display = "none";
                    if (clusterName == null || clusterName == "") {
                    return;
                    }
                    clusters.add(clusterName);
                    for (node of nodes) {
                        // check if cluster
                        if(network.isCluster(node) === true){
                            // get all nodes in cluster
                            var cluster = network.body.nodes[node];
                            for(let node in cluster.containedNodes){  // loop over contained nodes
                                // add cluster name to node
                                nodeDict[node].cluster = clusterName;
                            }
                        }else{
                            nodeDict[node].cluster = clusterName; // TODO CHECK INDEX MATCHING! 
                        }
                    }
                    // press cluster button
                    document.getElementById("clusterButton").click();
                }
        }
        });

        document.querySelector('#tasks-close-button').addEventListener('click', function() {
            var infobox = document.querySelector('#taskscontent');
            var closeButton = document.querySelector('#tasks-close-button');
            if (infobox.style.display === 'none') {
                infobox.style.display = 'block';
                closeButton.textContent = 'x';
            } else {
                infobox.style.display = 'none';
                closeButton.textContent = 'o';
            }
        });

        document.querySelector('#info-close-button').addEventListener('click', function() {
            var infobox = document.querySelector('#infocontent');
            var closeButton = document.querySelector('#info-close-button');
            if (infobox.style.display === 'none') {
                infobox.style.display = 'block';
                closeButton.textContent = 'x';
            } else {
                infobox.style.display = 'none';
                closeButton.textContent = 'o';
            }
        });
    </script>
</body>
</html>
